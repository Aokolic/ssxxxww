# PRD: 凭证轮换机制修复

## 1. 问题背景

用户在生产环境中观察到，我们的凭证轮换机制似乎存在缺陷。具体表现为，系统在轮换凭证时，似乎总是重复使用同一个 Project ID，而不是按预期在凭证池中循环。这表明 `CredentialManager` 类中的索引更新逻辑可能存在问题。

## 2. 问题分析

根据用户反馈，问题可能出在 `get_next_credential` 方法中的 `self.current_index` 更新逻辑。目前的实现可能存在以下一种或多种情况：

*   **非原子性操作**: 在高并发环境下，多个线程或进程可能同时读取 `self.current_index` 的旧值，然后各自计算新的索引值并写回。这会导致“写后写”冲突，最终只有一个更新生效，而其他线程的更新则会丢失。
*   **逻辑错误**: `self.current_index` 的更新逻辑本身可能存在缺陷，导致它在每次调用后都被重置为相同的值。
*   **状态未持久化**: 如果 `CredentialManager` 的实例在每次请求后都被重新创建，那么 `self.current_index` 的状态将不会在多次调用之间保持。

## 3. 目标

*   诊断 `CredentialManager` 中 `get_next_credential` 方法的索引更新逻辑，找出导致凭证无法正确轮换的根本原因。
*   修复该逻辑，确保在高并发场景下，凭证能够按照预期在池中均匀、循环地使用。
*   确保修复后的代码健壮、高效，并有相应的日志记录以供未来监控。

## 4. 关键功能点

*   **线程安全的索引更新**: 必须确保 `self.current_index` 的读取和更新操作是原子性的，以避免竞态条件。
*   **正确的索引循环**: 索引更新逻辑必须正确地在凭证池的大小范围内循环 (0 到 `pool_size - 1`)。
*   **状态持久化**: 确保 `CredentialManager` 的实例是单例或以其他方式在应用生命周期内保持状态。

## 5. 验收标准

*   在多次连续调用 `get_next_credential` 方法后，返回的凭证（及其关联的 Project ID）应该按顺序轮换。
*   在模拟的并发测试中，凭证轮换机制依然能够正常工作，不会出现重复使用或跳过凭证的情况。
*   相关的单元测试或集成测试能够覆盖修复后的逻辑，并验证其正确性。